<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLIDE PUZZLE></title>
    <link rel="stylesheet" href="styles.css">
   

</head>
<body>
    <div id=" puzzle_container"> 
        
        <div class="puzzle_block"1>1</div>
        <div class="puzzle_block"2>2</div>
        <div class="puzzle_block"3>3</div>
        <div class="puzzle_block"4>4</div>
        <div class="puzzle_block"5>5</div>
        <div class="puzzle_block"6>6</div>
        <div class="puzzle_block"7>7</div>
        <div class="puzzle_block"8>8</div>
        
        </div>

        <div id=" idfficulty_container">
            <div class=" difficulty_button"> EASY </div>
            <div class=" difficulty_button">MEDIUM </div>
            <div class=" difficulty_button"> HARD</div>
        </div>
        
    <script>
       const GameDifficulty=[20,50,70];
       class Game{
        difficulty;//difficulty based on GameDifficulty array
        cols=3;//how many colomns
        rows=3;//how many *rows
        count;//*rows
        blocks;// the html elements with classname=" puzzle_block"
        emptyblockcoords=[2,2]; //the coordinates of the empty block
        indexes=[]; // keeps track of the order of the blocks

        constructor (difficultyLeve1=1){
            this.difficulty=GameDifficulty[difficultyLeve1];
            this.count=document.getElementsByClassName("puzzle_block");//grab the blocks
            this.init();
        }
       }
       function init() { //position each block in its proper position
                for(let y=0;y<this.rows;y++){
                for(let X=0;x<this.cols;x++){
                    let blockidx=x+y*this.cols;
                    if(blockidx+1>=this.count)break;
                    let block=this.blocks[blockidx];
                    this.positionblockAtcoord(blockidx,x,y);
                    block.addeventlistener("click",(e)=>this.onclickonblock(blockidx));
                    this.indexes.push(blockidx);

                }
            }
       }
            this.indexes.push(this.count-1);
            this.randomize(this.difficulty);
            
        
        function randomize(iterationcount){//move a random block(x iterationcount)
            for( let i=0;i<iterationcount;i++){
                let randomblockidx=math.floor(math.random()*(this.count-1));
                let moved=this.moveblock(randomblockidx);
                if(!moved)i--;
            }
        

        }
        function moveblock(blockidx){//moves a block and return true if the block has moved
            let block=this.blocks[blockidx];
            let blockcoords=this.canmoveblock(block);
            if(blockcoords!=null){
                this.positionblockAtcoord(blockidx,this.emptyblockcoords[0],this.emptyblockcoords[1]);
                this.indexes[this.emptyblockcoords[0]+this.emptyblockcoords[1]*this.cols]=this.indexes[blockcoords[0]+blockcoords];
                this.emptyblockcoords[0]=blockcoords[0];
                this.emptyblockcoords[1]=blockcoords[1];
                return true;
            }
                return false;
        }
        function canmoveblock(block){//return the block coordinates if he can move else return null
            let blockpos=[paresInt(block.style.lift),parseInt(block.style.top)];
            let blockwidth=block.clientwidth;
            let blockcoords=[blockpos[0]/blockwidth,blockpos[1]/blockwidth];
            let diff=[math.abs(blockcoords[0]-this.emptyblockcoords[0]),Math.abs(blockcoords[1]-this.emptyblockcoords[1])];
            let canmove=(diff[0]==1&&diff[1]==0||(diff[0]==0&&diff[1]==1));
            if(canmove)return blockcoords;
            else return null;


            }
            function positionblockAtcoord(blockidx,x,y){//position the block at a certain coordinates
                let block=this.blocks[blockidx];
                block.style.lift=(x*block.clientWidth)+"px";
                block.style.top=(y*block.clientWidth)+"px";

            }
            function onclickonblock(blockidx){//try move block and check if puzzle was solved
                if(this.moveblock(blockidx)){
                    if(this.checkpuzzlesolved()){
                        setTimeout(()=>alert("puzzle solved!!"),600);
                    }
                }
            }

            function checkpuzzlesolved(){//return if puzzle was solved
                for(let i=0;i<this.indexes.length;i++){
                    //console.log(this.indexs[i],i);
                    if(i==this.emptyblockcoords[0]+this.emptyblockcoords[1]+this.cols)continue;
                    if(this.indexes[i]!=i)return false;
                }
                    return true;
            }
            function setdifficulty(difficultyLeve1){//set difficulty
                this.difficulty=GameDifficulty[difficultyLeve1-1];
                this.randomize(this.difficulty);

            }
            var game=new Game(1);//instantiate a new Game

            //taking care of the difficulty buttons
            var difficulty_buttons=Array.form(document.getElementsbyclassname("difficulty_button"));
            difficulty_buttons.foreach((elem,idx)=>{
                elem.addeventlistener("click",(e)=>{
                    difficulty_buttons[GameDifficulty.indexof(game.difficulty)].classList.remove("active");
                    elem.classList.add('active');
                    game.setdifficulty(idx+1);
                });

            });
                


                
            
